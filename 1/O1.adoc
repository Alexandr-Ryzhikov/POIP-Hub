:imagesdir: Picture

== Отчет 1
== Задание 1
* Создать проект C++ с main.cpp

Для создания проекта использовалась програма IAR Embedded Workbench

image::O1_1.png[]
Рисунок 1 - Создание проекта

Выбираем Язык С++ и глобальную функцию main

image::O1_2.png[]
Рисунок 2 - Выбор языка программирования и глобальной функции

Сохраняем проект. В свойствах проекта выбираем модель микроконтроллера ST ⇒ STM32F4⇒ STM32F411⇒ ST STM32F411RE (ПКМ по проекту, Options и в категории General Option выбрать Target.

image::O1_3.png[]
Рисунок  3 - Выбор микроконтроллера

Нынешний вид проекта:

image::O1_4.png[]
Рисунок 4 - Вид проекта

* Подключить к проекту файл cstartup.cpp

Сначала надо найти cstartup.cpp. Для этого для этого открываем командую строку (cmd) и вводим:

----
git clone https://github.com/lamer0k/CortexLib.git
----

image::O1_5.png[]
Рисунок 5 - Копирование папки через командную строку

Указанные по ссылке файлы будут в C::\User\User.

В папке находим файл cstartup.cpp.Добавляем к проекту (ПКМ по проекту,  Add⇒Add Files…, выбрать файл startup_stm32F411.cpp).

image::O1_6.png[]
Рисунок 6 - Добавление файла

* Создать папки AbstractHardware/Registers/FiledValues, Common, Application, FreeRtos

Данные папки требуется создать в папке, кеуда был сохранен проект. Так же их можно скопировать с клонированной папки преподавателя.

image::O1_7.png[]
Рисунок 7 - Структура после добавления папок

* Создать структуру проекта в соответствии со структурой папок

Теперь необходимо создать точно такую же структуру в проекте IAR Workbench, как и структура папок. ПКМ по проекту , Add=>Ggroup.Создать группы Abstract_Hardware, Application, Common, FreeRtos, идентичные скопированным.

image::O1_8.png[]
Рисунок 8 - Изменение структуры проекта

В итогде структура выглядит так:

image::O1_9.png[]
Рисунок 9 - Структура проекта

* Настроить stack и heap

Для включения анализа глубины стека необходимо поставить галочку в меню Option=>Linker=>Advanced=>Enable stack usage analysis

image::O1_10.png[]
Рисунок 10 - Анализ глубины стэка

* Скопировать содержимое папок Registers и Common в папки проекта

Все файлы скопированы

* Написать программу в main.cpp

Код взят из примера программы преподавателя

----
#include "gpioaregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOA::ODR::ODR5::Enable::Set() ;
  GPIOA::ODR::ODR5::Disable::Set() ;
  return 0 ;
}
----

Во время компиляции возникли ошибки. Это из-за того, что в файлах gpioafieldvalues.hpp и rccfieldvalues.hpp значения регистра ODR5 были Value1, Value0, а не Enable, Disable.

image::O1_11.png[]

image::O1_12.png[]



Kомпиляция прошла успешно, диоды мигают.

== Задание 2

Далее прошиваем программу в микроконтроллер.

Сначала проводим отладку отладку в симуляторе для проверки работоспособности программы.

* Откомпилировать и отлинковать программу

Для компиляции без загрузки в симулятор можно воспользоваться командой make

image::O1_16.png[]

Ошибок не выявлено

* Запустить программу в симуляторе

Для запуска симуляции используем следующию кнопку

image::O1_17.png[]

Или сочетание клавиш *Ctrl+D*

* Сделать пошаговую отладку

Пошаговая отладка выполняется следующими кнопками:

image::O1_18.png[]

Или горячими клавишами *F10, F11, F12*

* Настроить Debugger на отладку через StLink

ПКМ по проекту, Options, ST-LINK и выбираем параметры В соответствии с рисунком

image::O1_19.png[]

* Подключить плату к компьютеру

Подключаем плату к компьютеру через USB порт.

При скачивании IAR должны быть установлены все необходимые драйвера, в противном случае программа не увидит плату

* Загрузить программу в плату

Загружаем программу в плату через *Ctrl+D* или кнопку.

Теперь проводим отладку на плате

* Выполнить пошаговую отладку

Выполняем пошаговую отладку клавишей *F10*.

* Описать полученный результат

Код программы с построчным описанием:

----
#include "gpioaregisters.hpp" //for GPIOA
#include "rccregisters.hpp"   //for RCC

int main() //глобальная функция
//тело функции. <<Рисунок
{
   RCC::AHB1ENR::GPIOAEN::Enable::Set(); //Razreshaem tactirovanie na A
  GPIOA::MODER::MODER5::Output::Set();  //Zdaem ODR5 kak vihod
  GPIOA::ODR::ODR5::Enable::Set(); //Vkluchaem ODR5
  GPIOA::ODR::ODR5::Disable::Set(); //Vikluchaem ODR5
  
  return 0;
}
----

== Задание 3

Следующим заданием являлось работа с организацией памяти, настройкой стека и кучи. При неверной настройке данных параметров программа может не выполняться. Так же грамотная настройка позволит нам сократить вес итоговой программы.

* Запустить анализатор стека. Узнать рекомендуемый размер стека.

При настройке мы включили анализ стека.(Рисунок 10) Рекомендуемый размер стека мы можем посмотреть в .map файле. Рекомендуемый размер стека:
16

image::O1_22.png[]

* Изменить в проекте размер стека на рекомендуемый

Изменим в проекте размер стека на рекомендуемый

image::O1_23.png[]

* Описать содержание map файла

В .map файле написаны размеры составляющих проекта Мы можем увидеть размер стека

image::O1_24.png[]

Размер отдельных элементов:

image::O1_25.png[]

Размер нашего файла:

image::O1_26.png[]

* Поставить размер HEAP равный нулю. Объяснить почему так можно сделать. И почему STACK нельзя

Размер кучи HEAP можно поставить в 0, поскольку в программе не используется динамическая память. Размер STACK в ноль поставить нельзя, т.к. при использовании функций будет невозможна запись адреса возврата. Однако, в нашем случае, путем эксперимента было установлено, что даже при выставлении 0 в стеке программа запускается.

* Добавить проект в Git и сделать синхронизацию с GitHub [check]

* Сделать отчет по каждому пункту каждого задания в файле .adoc. Выложить файл в GitHub [check]

* Прислать ссылку на GitHub преподавателю для проверки [check]