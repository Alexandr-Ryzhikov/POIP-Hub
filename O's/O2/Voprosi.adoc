:imagesdir: Pics
== Вопросы


== 1) то такое POD типы данных?

POD - это тип (включая классы), в котором компилятор C++ гарантирует, что в структуре не будет ничего необычного. Они представлены в следующем вопросе.

== 2) Назовите все виды типов в языке С++

Виды типов были приведены в лекции

image::Figure3.png[]

== 3) Что такое пользовательский тип?

Это типы, созданные пользователем, struct, например.

== 4) Назовите модификаторы типов

Табличка с модификаторами была дана в лекции

[#Встроенные типы С++ модификаторы]
.Встроенные типа С++ модификаторы
[options="header"]
[cols="2,1, 7"]
|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

== 5) Назовите правило установки размеров типов

Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров
типов существует правило:
[.source, cpp]
----
1             <= sizeof(char)     <= sizeof() <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----

Поэтому вместо прямых типов типа int, используйте псевдонимы, например:
[horizontal]
std::uint32_t:: целое беззнаковое длиной 32 бита
std::int64_t::  целое знаковое длинной 64 бита
std::uint8_t:: целое знаковое длинной 8 бит

== 6) Что делает оператор sizeof()?

sizeof - это унарный оператор, возвращающий длину в байтах переменной или типа, помещенных в скобки.

== 7) Что характеризует тип std::size_t

size_t всегда безнаковый тип. Это специальный тип для указания размера, он уникален тем, что размер этого типа равен максимальному возможному размеру объекта для данной архитектуры. т.е. для 32битной архитектуры - это 2^32 ну или другими словами это псевдоним типа uint32_t. Для 64 машины это уже будет 2^64 или псевдоним типа std::uint64_t

== 8) Назовите фиксированные типы целых в библиотеке std

. int8_t - тип c 1 байт signed, с диапазоном значений от -128 до 127;
. uint8_t - тип c 2 байтами unsigned, с диапазоном значений от 0 до 255;
. int16_t - тип c 2 байтами signed, с диапазоном значений от -32 768 до 32 767;
. uint16_t - тип c 2 байтами unsigned, с диапазоном значений от  0 до 65 535;
. int32_t - тип 4 байтами signed, с диапазоном значений от -2 147 483 648 до 2 147 483 647;
. uint32_t - тип c 4 байтами unsigned, с диапазоном значений от 0 до 4 294 967 295;
. int64_t - тип c 8 байтами signed, с диапазоном значений от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807;
. uint64_t - тип c 8 байтами unsigned, с диапазоном значений от от 0 до 18 446 744 073 709 551 615.

== 9) Что такое псевдоним типа?

Введенное пользователем сочетание букв и цифр, для более удобного обращения

== 10) Что такое явное и неявное преобразование типа?

Явное - когда преобразование напрямую прописано в коде пользователем. Неявное - когда это делает компилятор сам.

== 11) Какие явные преобразования типов вы знаете?

Для преобразования из одного типа используют следующие команды преобразования:

. static_cast
. const_cast
. reinterpret_cast
. dynamic_cast

== 12) Что делает reinterpret_cast?

Преобразовывает типы, которые несовместны друг с другом. В одной из предыдущих лабораторных работ с помощью reinterpret_cast мы преобразовывали адреса регистров в указатели.

== 13) Чем static_cast отличается от reinterpret_cast?

С помощью static_cast преобразовывают только смежные типы, например переменные с плавающей точкой к целочисленным.

== 14) Что такое ОЗУ и ПЗУ?

ОЗУ - оперативная память, в которую можно записывать программы и переменные, и затем считывать оттуда. ПЗУ - постоянная память, данные с которой можно только считывать.

== 15) Каков размер памяти ARM Cortex микроконтроллеров?

Ядро ARM снабжено 4Гбайт оперативной памяти с адресами от 0x00000000 до 0xFFFFFFFF.

== 16) По какой архитектуре разработан ARM Cortex микроконтроллер?

Данный микроконтроллер разработан по Гарвардской системе. Память этого микроконтроллера разделена на три отдела:

. ПЗУ - память, в которой содержится непосредственно программа.
. ОЗУ - память для хранения временных данных, при необходимости и программы, а также регистров, отвечающих за настройку и работу с периферйными устройствами.
. Память, в которой хранятся данные EEPROM.

== 17) В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?

Устройства с архитектурой Фон Неймана не способны одновременно оперировать с данными (считывать их переписывать) и считывать алгоритм действий, так как для этих действий используется одна шина.
Устройства с гарвардской архитектурой могут считывать команды и оперировать данными одновременно, так как потоки команд и данных идут по разным шинам.

== 18) Где располагаются локальные переменные?

Локальные переменные располагаются в регистрах или стеке.  

== 19) Где располагаются статические переменные?

Статичиские переменные передаются в тот же сегмент памяти, где хранятся глобальные переменные.

== 20) Где располагаются глобальные переменные?

Глобальные переменные располагаются в фиксированной области памяти, указанной компилятором.

== 21) Что такое стек?

Абстрактный тип данных, представляющий собой список элементов по принципу : последним пришел, а вышел первым.

== 22) Что такое указатель?

Указатель это переменная, которая хранит расположение (адрес) другой переменной.

== 23) Что такое разыменовывание указателя?

Это когда переменной, которой присвоен указатель, вместо него присваивают некую другую переменную.

== 24) Что означает взятие адреса?

Указатель - это адрес переменной в памяти. Указатель на адрес можно хранить в переменной. 
Взятие адреса производится оператором & - это унарный оператор, возвращающий адрес операнда в памяти. С его помощью в одну переменную можно поместить адресс другой переменной.

== 25) Какие операции можно выполнять над указателями?

Указатели одного типа можно складывать, вычитать и сравнивать.

== 26) Что такое константный указатель?

Константный указатель - это указатель с неизменным значением.

== 27) Что такое указатель на константу?

Простой указатель с адрессом неизменной переменной.

== 28) Что такое ссылка? В чем её отличие от указателя?

Ссылка это псевдоним переменной. У ссылки нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет выведен адрес переменной, на которую она ссылается.
Ссылка ведет себя почти также как константный указатель. Её нельзя изменять, складывать, вычитать и сравнивать.
Ссылка не может быть не проинициализирована.

== 29) Что такое регистр?

Блок ячеек памяти, образующий сверхбыструю оперативную память внутри процессора.

== 30) Что такое регистры общего назначения?

Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

== 31) Что такое регистры специального назначения?

Это регистры, используемые для управления процессором и периферией, расположенные в ОЗУ.

== 32) Как можно установить бит в регистре специального назначения?

Узнать, какой регистр за что отвечает, найти его адрес, и командой установить нужный бит  1,  по дефолту с помощью Value1, либо 0 (Value0).

== 33) Объясните как вызывается функция?

Чтобы компилятор мог вызвать функцию, он должна быть правильным образом объявлена. Все правила, связанные с вызовом функции, представленны в Соглашении о вызовах

=== Соглашение о вызовах
Соглашение об вызовах включает в себя:
* Объявление функции
* Компоновка С и С++ кода
* Последовательность использования оперативных регистров и вспомогательные регистров
* Вход в функцию
* Выход из функции
* Обработка адреса возврата

=== Объявление функции
Функция должна быть объявлена в таком порядке, чтобы компилятор мог узнать как её вызвать.
Объявление функции может выглядеть следующим образом:
====
int MyFunction(int first, char * second);
====
Все что знает об этой функции компилятор, это то, что она принимает два параметра: целое и указатель
на символ. И функция должна вернуть целое значение. Этого достаточно для компилятора, чтобы понять
как вызвать эту функцию.

=== Компоновка С и С++ кода
В C+ +, функция может компоноваться либо как С+ +, либо как С функция. Пример объявления функции
с Си компоновкой:
[source, c]

----
extern "C" {
  int F(int);
}
----

Если вы хотите вызвать функции ассемблера из С++, то лучше объявить эту функцию, как имеющую тип
компоновки Си

=== Вход в функцию
Параметры передающие в функцию могут использовать два метода:

* Через регистры
* Через стек

Для большей эффективности параметры передаются через регистры, но их число ограничено, поэтому
если регистров не хватает, то используется стек. Для передачи параметров используются
оперативные регистры *R0:R3*

=== Выход из функции
Функция может вернуть значение. Для возврата значения используются регистры *R0:R1*. Если значение
больше 64 бит, то в регистр R0 записывается адрес где лежат данные.

Вызывающая функция обязана очистить стек, после того, как вызываемая функция вернула значение.

== 34) Что такое трансляция?

Трансляция - это обработка процессором исходного файла.

== 35) Что такое компоновка?

Это объединение нескольких объектных файлов в один исполняемый файл.

== 36) Как лучше организовывать структуру проекта и почему?

Лучше разделить код на подразделы. В одних задаются тактирование и входы выводы, в других необходимые функции и структуры, а основной код должен только на них ссылаться. Тогда в случае изменения кода надо будет работать лишь с небольшим сегментом, а не перелопачивать весь код целиком, чтобы найти изменяемые элементы.

== 37) Что такое операторы?

Часть языка программирования, представляет собой команду или набор команд, в которой имеется последовательность действий.

== 38) Какие арифметические операторы вы знаете?

Арифметические операторы предоставляют базовые арифметические действия над типами, то есть сложение, вычитание, деление, умножение, остаток от деления, присваивание, унарный плюс, минус.

== 39) Какие логические операторы вы знаете?

Логические операторы предоставляют действия над булевым типов. Результат действия этих операторов может быть только true или false. Логическое отрицание (НЕ), логическое умножение (И), логическое сложение (ИЛИ).

== 40) Какие побитовые операторы вы знаете?

Побитовая инверсия, побитовое И(ИЛИ), побитовое исключающее ИЛИ, сдвиг влево или вправо.

== 41) Приведите пример переопределения оператора

(я тут не понял, переопределение это перегрузка? гугл по крайне мере так думает0

== 42) Какие еще операторы вы знаете?

* Арифметические операторы;

* Операторы знака;

* Префиксный и постфиксный инкременты;

* Логические операторы;

* Битовый сдвиг;

* Оператор присваивания;

* Операторы сравнения.

== 43) Как сбросить бит с помощью битовых операторов?

Пример из лабораторной:

----
*PointerOnODR5 |=(1<<5); //Vkluchenie LED1
   *PointerOnODR9 |=(1<<9); //Vkluchenie LED2
   *PointerOnODR8 |=(1<<8); //Vkluchenie LED3
 
 *PointerOnODR5 &= ~(1<<5); //Vikluchenie LED1
   *PointerOnODR9 &= ~(1<<9); //Vikluchenie LED2
   *PointerOnODR8 &= ~(1<<8); //Vikluchenie LED3
----

Здесь значение сбрасывется с помощью побитового И и побитовой инверсии.

== 44) Как установить бит с помощью битовых операторов?

Битовое ИЛИ может использоваться для установки битов. Любой бит, установленный в любом операнде, вызывает установку соответствующего бита в другом операнде. Например, в результате операции 128 | 3 получаем

  10000000     128 в двоичном представлении
  00000011     3 в двоичном представлении
| ------—     побитовое ИЛИ
  10000011     результат

== 45) Как поменять значение бита с помощью битовых операторов?

С помощью исключающего ИЛИ.

----
Panara10 = 10 0000 0000b ;

Panara10 ^= (1 <<10) ; //Panara станет равно 00 0000 0001b

Panara10 ^= (1 <<10) ; //Panara станет равно 10 0000 0001b

Panara10 ^= (1 <<10) ; //Panara станет равно 00 0000 0001b

Panara10 ^= (1 <<10) ; //Panara станет равно 10 0000 0001b
----

каждый десятый бит меняется на противоположный

== 46) Какой микроконтроллер на отладочной плате XNUCLE ST32F411?

STМ32F411RE (на нем написано)

== 47) Какие блоки входят в состав микроконтроллера STM32F411?

Блок системы, таймеров, интерфейса, аналоговой периферии, матрица шин, шина периферии

В блок системы входят: внешние, внутренние резонаторы, фапч, схема сброса и тактирования, часы реального времени, системный таймер, сторожевой таймер

image::Figure4.png[]


== 48) В чем отличие ядра CortexM4 от CortexM3?

Отличия в наборе инструкций: Thumb/Thumb-2​ (М3) Thumb/Thumb-2, DSP, SIMD, FP​ (М4).
Также у М3 отстуствует аппаратный модуль работы с плавающей точкой.

== 49) Назовите основные характеристики микроконтроллера STM32F411?

* 32 разрядное ядро ARM Cortex-M4

* Блок работы с числами с плавающей точкой FPU

* 512 кБайт памяти программ

* 128 кБайт ОЗУ

* Встроенный 12 битный 16 канальный АЦП

* DMA контроллер на 16 каналов

* USB 2.0

* 3x USART

* 5 x SPI/I2S

* 3x I2C

* SDIO интерфейс для карт SD/MMC/eMMC

* Аппаратный подсчет контрольной суммы памяти программ CRC

* 6 - 16 разрядных и 2 - 32 разрядных Таймера

* 1 - 16 битный для управления двигателями

* 2 сторожевых таймера

* 1 системный таймер

* Работа на частотах до 100Мгц

* 81 портов ввода вывода

* Питание от 1.7 до 3.6 Вольт

* Потребление 100 мкА/Мгц

== 50) Назовите дополнительные характеристики микроконтроллера STM32F411.

Из дополнительных особенностей, которые понадобятся для лабораторных работ следует выделить:

* Настраиваемые источники тактовой частоты

* Настраиваемые на различные функции порты

* Внутренний температурный сенсор

* Таймеры с настраиваемым модулем ШИМ

* DMA для работы с модулями (SPI, UART, ADC… )

* 12 разрядный ADC последовательного приближения

* Часы реального времени

* Системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ

== 51) Какие источники тактирования есть у микроконтроллера STM32F411

Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:​

* HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​

* HSE (high-speed external) — внешний высокочастотный генератор.​

* PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей, исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.​

Также имеются 2 вторичных источника тактового сигнала:​

* LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц.

* LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц.

== 52) Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411.

. Определить какие источники частоты нужны​(допустим, PLL);

. Включить нужный источник? используя Clock Control register (RCC::CR)​

. Дождаться стабилизации источника, через соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

. Назначить нужный источник на системную частоту​через Clock Configuration Register (RCC::CFGR)​

. Дождаться пока источник не переключиться на системную частоту​через Clock Configuration Register (RCC::CFGR)​

== 53) Что такое ФАПЧ?

Фазовая автоподстройка частоты (ФАПЧ, англ. PLL ) — система автоматического регулирования, подстраивающая фазу управляемого генератора так, чтобы она была равна фазе опорного сигнала, либо отличалась на известную функцию от времени. Регулировка осуществляется благодаря наличию отрицательной обратной связи. Выходной сигнал управляемого генератора сравнивается на фазовом детекторе с опорным сигналом, результат сравнения используется для подстройки управляемого генератора.

Система ФАПЧ используется для частотной модуляции и демодуляции, умножения и преобразования частоты, частотной фильтрации, выделения опорного колебания для когерентного детектирования и в других целях.



== 54) Что делает следующий код?

Производит обмен между StudentUdacha и PrepodUdacha.